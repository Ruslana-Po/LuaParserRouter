# LuaParserRouter
Информация:
Насчет lua операций 
1. В операторах присваивания не хватает ^=
2. В бинарных операторах нету ^
3.  Не верное не равно в бинарных операторах ~= , а там !=
4. Не уверена что это как ошибка, но в lua  логические операции пишутся or and not 
А не && || !
5. Не знаю нужно или нет но есть еще операции . И ..
6.  + это не унарная операция, так же инверсия тут ~, а не !
7. В луа нету ==
Насчет SetUp():
Я узнала что в Гугл тестах есть потайные камни. Что set и down тесты вызывают автоматически.  Поэтому, скорее всего, когда я пыталась еще одновременно и сама вызвать, происходила ошибка. 
Таким образом перед каждым тестом создается динамический экземпляр.
Таким образом если методы SetUp и TearDown закомментировать, то parser останется неинициализированным, а без TearDown будет утечка памяти если parser уже создали где нибудь

Умные указатели: 
Вообще узнав как автоматически работают методы в Гугл тестах, я поняла что можно их тогда заменить на умные указатели. Ведь принцип тот же, а запись короче.

Насчет проверки передачи nullptr.

При написании мною 
/*TEST_F(ParseCodeTest, ParseBodyWithNullRoot) {
    EXPECT_THROW(parse_code->ParseBody(nullptr), ParseException);
}*/
Будет ошибка: make: *** [makefile:25: run] Ошибка сегментирования (сделан дамп памяти)
Решение проблемы:
1. Использовать умные указатели в самом коде по. Они управляют временем жизни объекта и гарантируют, что он не будет уничтожен преждевременно. 
2. Реализовать в коде по проверку на nullptr, которой нету.
3. Я использовала EXPECT_DEATH. В программировании
 EXPECT_DEATH чаще всего означает ожидание определенного состояния программы, а именно её завершения с ошибкой, и используется в контексте тестирования, где проверяется, что функция или блок кода приводят к аварийному завершению или выбрасывают исключение.
